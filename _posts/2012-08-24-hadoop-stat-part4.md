---
layout: default
published: true
---

# Hadoop统计平台——MMStat（四）  

## 组织session和生成分类元数据--详细设计  
  
上一篇从数据流的角度讲述了组织session的map-reduce过程，而这一篇讲的就是这个过程的详细设计——组件之间如何配置、使用和协作从而稳定工作起来。  

从上一篇可以看到，组织session的mappe流程很简单，所以重点在于reduce过程，下面是reduce过程中参与流程的主要组件协作图：  
![组织session reducer的组件图1](/assets/component_session_reducer1.png)  
  
如图，reducer层次的组件结构很简单，就是一个reducer拥有两个map，每个map都是用日期字符串来做索引，根据日期字符串会各自有一个processor。组织session的reducer设计是可以处理多天的输入，而每个设备每天的session都应该有一个独立的processor来处理。这里可能会有一个疑问是，为何要每个日期对应一个processor，不能就用一个吗？的确是可以的，这就相当于在processor内部来维护分日期的计算，但这样可能会加大processor的设计复杂度，因此我选择在外部来做这个索引，简化processor，毕竟有一点很重要，那就是processor是功能扩展点，越是简化对processor的要求，功能开发会越快。  
当reducer每次接收完一个分组（一个设备号）的数据，就会组织session，最后把组织好的session交给属于当天的processor来处理。  
每个processor组件都要对组织session的reducer实现两个接口——Process和Finish，其中Process接口要接受被组织好的session数据结构，并且不能修改session任何数据；而Finish就是在reducer接收完所有分组后，并且即将要结束reduce过程的时候调用。只要工程师实现Processor的时候实现了上述的两个接口，而且不修改reducer的逻辑，那么代码就可以保证正确执行。  

在MMStat的设计里面我几乎没有用到继承（就写这篇文章的时候还没用过），都是基于模板的抽象和组件设计。我曾经是非常崇尚面向对象设计的人，在大学期间我非常沉迷各种设计模式和其应用，并非说OOP和设计模式有什么比不上模板编程的重大缺点，只是在一个复杂系统里面，我更趋向于在编译过程中发现设计上的误解，而不是到了运行时。毕竟像我所在的那种团队不可能开发出像.NET、JAVA这样设计得很好的平台组件库（我相信也没几家公司认为他们可以），基于这一点，根据我自己的经验，OOP中最核心的继承在实际工程环境中给工程师埋的坑远大于修出来的好路。  
当工程师写一个类，满怀兴奋地去继承前人写的类的时候，中间会有多少前人意料之外的设计误解，这都必须要等到系统实际运行起来才知道，更危险的是刚开始的时候运行起来也没问题，于是越来越多对该类的继承依赖，直到某天开发某个重要功能的时候才发现原来一直对最初继承的那个类有设计上的误解，那就成了最头痛的事情。这一篇文章不是专门用于讨论我对模板编程和面向对象编程的关系的，因此就不在这里多说了。或者以后能写这么一篇文章出来嗨皮一下，所以下面就回到正题。  
  
ClassifySessionDataProcessor是生成分类元数据的组件，也是最基础的组件，下面是他内部的组件图：  

