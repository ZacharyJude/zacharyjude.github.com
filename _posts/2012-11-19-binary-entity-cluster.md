---
layout: default
published: true
---

# 二元组实体（数据）聚类  

以前没有接触过聚类的工作，这是我第一次做聚类，在显示环境下的数据聚类要得出理想的效果，其难度远远大于我原来的想象，在过去一周我无数次因为不知所措而感到很沮丧，直到现在才能做出相对有效的聚类，觉得有必要为这一周多的苦逼写下一篇记录。  

## 背景
跟标题一样，这个聚类过程的输入是一对一对的二元组数据，在我的工作里面是(userID, shopID)，表示用户喜欢过这个商店。而聚类的期望目标就是按照把商店按照用户的喜好特点来聚类，也就是每个聚类中的商店，都具有代表一类用户偏好的特征。刚开始给出的目标是对(用户，商店)这个二分图进行聚类，同时获得用户的聚类{Ui}和商店的聚类{Si}，使得Ui里的用户都喜欢Si里面的商店。  

## 论文的开始
在会议室讨论这个聚类的时候，Austin认为这种二分图聚类的问题在业界应该是被研究得很透彻，因此应该有现成的解决方案，而会后，他的确给我找到了这样的一篇论文，而我在这个事情上的工作就从这一片论文正式开始。之所以说正式开始，因为在会议之前其实我已经有了一定的设计，写了一个算法来做这个事情，当然用的不是论文里面的高深方法，而是下面就要说到的一个错误的方法。  

## 错误的算法
针对这个问题的输入，很容易可以构造出两个倒排索引：(shopID, userIDs)和(userID, shopIDs)。我基于一个思考：如果各自喜欢两个商店的用户集合的交集大小达到一个阀值以上，那么这两个商店就应该具有一定的共同特征，这个特征的细化程度取决于阀值的大小，阀值越大，特征越是细化。扩大商店聚类的方式就是迭代每一个已有的聚类（初始的时候就是每个商店看作一个已有聚类），如果能通过喜欢用户群交集大小的阀值，就并入到已有聚类中，形成新的聚类这个算法有以下几个问题：  
第一，这样在第一轮里面的计算量会很大，因为是个n次方的扩展（N为扩展次数），从一个店的聚类扩展到两个店，就有m*m的可能候选聚类（m是商店的数量）；从两个店的聚类扩展到三个店，理论上就可能有m*m*m的处理复杂度。在一般情况下，如果阀值提高一点的话，经过第一轮扩展后，后续的扩展都不会达到很高的复杂度（通常都比第一轮扩展复杂度要低），因此性能问题不是这个算法最糟糕的地方。

第二，这个算法基于用户的交集来构造商店的聚类，而为了缓解上面第一个问题，使得程序能够在可接受的复杂度内完成计算，就必须让用户交集数量的阀值设置得比较高，在我的样本数据里面有105万用户和7800商店，在这个数据规模下经过测试我得起码把阀值设置到5000或以上才能让计算时长可接受。这样高的用户阀值会导致很严重的问题——使得由小众用户（5000以下的）构成的商店聚类在结果中消失，简单来说，因为为了让算法可执行，而丢弃了应该被注意到的聚类结果。并且在这个情况下最终计算出来的商店聚类也是基于大概5000用户的交集上，因为随着每个聚类扩展，共同的用户数量会锐减。而在实际结果下，聚类大小达到4个店铺就已经无法扩展了（也就是不存在5个店铺拥有5000以上共同的用户）。  

起初我以为在第二、三轮扩展的时候把阀值降低或许能缓解问题，没错，这样虽然可以让聚类大小增加一点（成了大小为6个聚类），但这样跟预期想要的还是差太远了，毕竟我们的聚类目标是希望，通过分析聚类中的商店共同的特征，假设成用户的爱好，然后对用户群进行划分，这样只有5，6个商店的聚类根本不能作为研究对象。这个算法通过对已有的聚类进行扩展，会得出这样的结果，{S1,S2,S3,S4}、{S1,S2,S3,S5}、{S2,S3,S4,S5}、{S1,S2,S4,S5}等等只相差一个商店的聚类结果，如果聚类大小更大的话，会产生更多这样的结果，但正如前面提到，才5、6个商店大小的聚类就无法再扩展了；基于这个情况，我选择把聚类给合并一下，顺便也通过这样扩大聚类的size，然后当我一合并就发现所有商店几乎都会merge到一起，原因是因为这些聚类之间本来相差的商店就不多，而构造过程都基于交集用户，于是最终导致一个结果——所有不同聚类中的商店其实都拥有一部分共同用户，在我的运行结果中大概是3000个。当我搞懂这一点以后，我彻底明白这个算法是错误的。
